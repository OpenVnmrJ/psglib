
/* gocsy - A sequence to do (selective)TOCSY  (1D,2D,3D)
                Z-filter before acquisition dimension

Selective Excitation:
  controlled by selflg='y'
  selective pulse excites a specific multiple by
  a shaped pulse "selshape" of power "selpwr" 

These parameters can be automatically generated by the macro
"setshape". The Tocsy period is "mix1" at a power "slpwr" following a trim
pulse where the 90 degree pulse width is slpw (MLEV17).

1D:
Zero-quantum multiplet distortions in 1D tocsy may be averaged away by running 
an array of d3 values, e.g. from 100 to 500usec and adding the fids.

2D:
A tocsy-tocsy 2D experiment can be done by setting mix2,ni2>0. 

3D: (band selective in F1)
set both ni and ni2. Here sw1 would normally be narrow,
just enough to record the band selected by the selective pulses. Use f1lsfrq
equal to the offset from tof to the center of the excited band for 
proper display

3D processing:

	ft3d transform with default coefficients works.
        for transform with ft3da (userlib) macro:
        f1coef = '1 0 0 0 0 0 -1 0'
        f2coef = '1 0 0 0 0 0 1 0'
	
	rp = rp(s2pul) rp1=0 rp2=0
	Check phase correction with wft2da('ni',1) and wft2da('ni2',1)

        nt = 4 (ideal)
             2 (minimum with F1 FADed axials)
        fadflg = 'y' (if center of selected band = N*sw1 away from tof)
                        FAD to move axials to the edge of F1
                        lsfrq1 = N*sw1 retains the axials at the edge
               = 'n' (if center of selected band = ((2N+1)*sw1)/2 away from tof)
                        Leave the axials in the middle of F1 and
                        shift it to the edge with lsfrq1 = ((2*N+1)sw1)/2

        selflg = 'y' (turns on dpfgse band selection)
        homodec = 'y' (turns on BASHD)
          BAnd Selected Homonuclear Decoupled (BASHD) F1 dimension
          as per V.V. Krishnamurthy (Magn. Reson. Chem., submitted)

Krish Krishnamurthy (Feb. 1996)
Modified for 1D tocsy  George Gray (Jul 1996)
*/

#include <standard.h>
extern int dps_flag;

mleva()
{
 double slpw;
 slpw = getval("slpw");
 txphase(v2); delay(slpw); 
 xmtroff(); delay(slpw); xmtron();
 txphase(v3); delay(2*slpw); 
 xmtroff(); delay(slpw); xmtron();
 txphase(v2); delay(slpw);
}

mlevb()
{
 double slpw;
 slpw = getval("slpw");
 txphase(v4); delay(slpw); 
 xmtroff(); delay(slpw); xmtron();
 txphase(v5); delay(2*slpw); 
 xmtroff(); delay(slpw); xmtron();
 txphase(v4); delay(slpw);
}


static int 	ph1[8] = {0,2,0,2,1,3,1,3},
		ph6[8] = {0,2,0,2,1,3,1,3},
		ph4[8] = {0,0,0,0,1,1,1,1},
		ph5[8] = {0,0,2,2,1,1,3,3},
		ph2[8] = {0,0,0,0,1,1,1,1},
		ph3[8] = {0,2,2,0,1,3,3,1};


pulsesequence()
{
  double	mix1,
                mix2,
		slpwr,
		slpw,
                trim,
		cycles1,
		cycles2,
                   gzlvl1,
                   gt1,
                   gzlvl2,
                   gt2,
		   gzlvl3,
		   gt3,
                   gstab,
                   selpwr,
                   selpw,
		hsgpwr;
   char 	sspul[MAXSTR], 
                   selshape[MAXSTR],     
		   selflg[MAXSTR],
		   homodec[MAXSTR],
                   fadflg[MAXSTR];
   int		iphase,
		iphase2;

   mix1=getval("mix1");
   mix2=getval("mix2");
   slpwr=getval("slpwr");
   slpw=getval("slpw");
   trim = getval("trim");
   gzlvl1 = getval("gzlvl1");
   gt1 = getval("gt1");
   gzlvl2 = getval("gzlvl2");
   gt2 = getval("gt2");
   gzlvl3 = getval("gzlvl3");
   gt3 = getval("gt3");
   gstab =getval("gstab");
   selpwr = getval("selpwr");
   selpw = getval("selpw");
   getstr("selshape",selshape);
   getstr("selflg",selflg);
   getstr("homodec",homodec);
   getstr("fadflg",fadflg);
   hsgpwr=getval("hsgpwr");

   cycles2 = (mix2-trim)/(99.67*slpw);
   cycles2 = (double)(int)(cycles2);
   initval(cycles2,v10);
   cycles1 = (mix1 - trim)/(96.67*slpw);
   cycles1 = (double)(int)(cycles1);
   initval(cycles1,v11);

   getstr("sspul",sspul);
   iphase = (int)(getval("phase")+0.5);
   iphase2 = (int)(getval("phase2")+0.5);


   settable(t1,8,ph1);
   settable(t6,8,ph6);
   settable(t4,8,ph4);
   settable(t5,8,ph5);
   settable(t2,8,ph2);
   settable(t3,8,ph3);

    getelem(t1,ct,v1);
    getelem(t2,ct,v2);
    getelem(t5,ct,v9);
    getelem(t3,ct,oph);

    if (iphase == 2)
	incr(v1);
    if (iphase2 == 2)
	incr(v9);

   assign(v1,v7);
   add(v7,two,v8);

    initval(2.0*(double)(((int)(d2*getval("sw1")+0.5)%2)),v13);
    initval(2.0*(double)(((int)(d3*getval("sw2")+0.5)%2)),v14);  

   if (fadflg[0] == 'y')
   {
    add(v1,v13,v1);
    add(oph,v13,oph);
   }
    add(v9,v14,v9);
    add(oph,v14,oph);


    add(v2,one,v3); add(v3,one,v4); add(v4,one,v5);


   status(A);
     obspower(tpwr);
     delay(50.0e-6);

     if (sspul[0] == 'y')
      { 
	zgradpulse(hsgpwr,2.0e-3);
	rgpulse(pw,zero,rof1,rof1);
	zgradpulse(hsgpwr,2.0e-3);
      }
     delay(d1);

     if (satmode[0] == 'y')
      {
	obspower(satpwr);
	if (satfrq != tof)
	 obsoffset(satfrq);
	rgpulse(satdly,zero,10.0e-6,10.0e-6);
	if (satfrq != tof)
	 obsoffset(tof);
	obspwrf(4095.0); obspower(tpwr);
       }

     rgpulse(pw, v1, rof1, 1.0e-6);

   status(B);

     if (selflg[0] == 'y')
      {
       if (homodec[0] == 'y')
       {
	if (d2/2 > 0.0)
		delay(d2/2 - (2*pw/PI) - pw - 2.0e-6);
	else
		delay(d2/2);
        rgpulse(2*pw,t6,1.0e-6,1.0e-6);
       }
       else
       {
	if (d2 > 0.0)
		delay(d2 - (2*pw/PI) - 1.0e-6);
	else
		delay(d2);
       }

        delay(gstab);
        zgradpulse(gzlvl1,gt1);
        obspower(selpwr);
        delay(gstab);
        shaped_pulse(selshape,selpw,v7,rof1,rof1); 
        delay(gstab); 
        zgradpulse(gzlvl1,gt1);
        delay(gstab);
       if (homodec[0] == 'y')
       {
	if (d2/2 > 0.0)
		delay(d2/2 - pw - 1.0e-6);
	else
		delay(d2/2);
       }
        delay(gstab); 
        zgradpulse(gzlvl2,gt2);
        delay(gstab); 
        shaped_pulse(selshape,selpw,v8,rof1,rof1);  
        delay(gstab); 
        zgradpulse(gzlvl2,gt2);
        delay(gstab);
      }
     else
      {
	if (d2 > 0.0) 
                delay(d2 - (2*pw/PI) - 1.0e-6 - POWER_DELAY); 
        else 
                delay(d2); 
       }

     obspower(slpwr); obspwrf(4095.0);

   status(C);
        if (cycles1 > 1.0)
         {
	  if (dps_flag)
	     {  rgpulse(trim,zero,rof1,rof1);
		rgpulse(mix1,zero,rof1,rof1); }
	  else
	  {
	   rcvroff();
	   delay(5.0e-6);
	   xmtron();
	   txphase(v3); delay(trim);
	   starthardloop(v11);
            mleva(); mleva(); mlevb(); mlevb();
            mlevb(); mleva(); mleva(); mlevb();
            mlevb(); mlevb(); mleva(); mleva();
            mleva(); mlevb(); mlevb(); mleva();
            txphase(v3); delay(0.67*slpw);
	   endhardloop();
	   xmtroff();
	   delay(5.0e-6);
	   rcvron();
	  }
         }

    status(D);
	obspower(tpwr);
	rgpulse(pw,t4,1.0e-6,rof1);
	delay(gstab);
	zgradpulse(gzlvl3,gt3);
	delay(gt3);
	rgpulse(pw,v9,rof1,1.0e-6);

	if (d3 > 0.0)
	 delay(d3 - (2*pw/PI) - 6.0e-6 - POWER_DELAY);
	else
         delay(d3);

    status(E);
	obspower(slpwr);
       if (cycles2 > 1.0)
       {
	if (dps_flag)
	    {   rgpulse(trim,zero,rof1,rof1);
		rgpulse(mix2,zero,rof1,rof1);  }
	else
	{
	rcvroff();
	delay(5.0e-6);
	xmtron();
	txphase(v3); delay(trim);
       starthardloop(v10);
            mleva(); mleva(); mlevb(); mlevb();
            mlevb(); mleva(); mleva(); mlevb();
            mlevb(); mlevb(); mleva(); mleva();
            mleva(); mlevb(); mlevb(); mleva();
            txphase(v3); delay(0.67*slpw);
       endhardloop();
	xmtroff();
	delay(5.0e-6);
	rcvron();
        }
       }
       obspower(tpwr);

      delay(rof2 - POWER_DELAY);

   status(F);
}
